<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>ttg: Main Page</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">ttg 0.1.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Overview</span></a></li>
      <li><a href="userguide.html"><span>User&#160;Guide</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer&#160;Guides</span></a></li>
      <li><a href="usergroup1.html"><span>Source&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ttg Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <img src="https://github.com/TESSEorg/ttg/workflows/CMake/badge.svg" alt="Build Status" style="pointer-events: none;" class="inline"/></p>
<h1>TTG</h1>
<p>This is the C++ API for the Template Task Graph (TTG) programming model for flowgraph-based composition of high-performance algorithms executable on distributed heterogeneous computer platforms. The TTG API abstracts out the details of the underlying task and data flow runtime; the current realization is implemented using <a href="https://github.com/m-a-d-n-e-s-s/madness">MADNESS</a> and <a href="https://bitbucket.org/icldistcomp/parsec.git">PaRSEC</a> runtimes as backends.</p>
<h1>Why TTG?</h1>
<ul>
<li>TTG marries the idea of flow programming models with the key innovations in the PARSEC runtime for compact specification of DAGs (PTG).</li>
<li>TTG can efficiently compose and execute irregular computation patterns which are poorly served by the current programming and execution models.</li>
<li>TTG has strong support for distributed hybrid architectures for running modern scientific algorithms efficiently on current and near-future supercomputers.</li>
</ul>
<h1>Installation</h1>
<ul>
<li>To try out TTG in a Docker container, install Docker, then execute <code>bin/docker-build.sh</code> and follow instructions in <code>bin/docker.md</code>;</li>
<li>See <a href="https://github.com/TESSEorg/ttg/blob/master/INSTALL.md">INSTALL.md</a> to learn how to build and install TTG.</li>
</ul>
<h1>Key Concepts of TTG</h1>
<ul>
<li><code>TaskId</code> (aka <code>Key</code>): A unique identifier for each task. It should be hashable. For example, if computing a matrix multiplicaion, TaskId could be a triplet of integers identifying the tiles being operated upon.</li>
<li><code>Terminal</code>: Input and output arguments are exposed by the runtime as terminals. Input terminal is a single assignment variable and is used by the runtime to determine when arguments of a task are available. An input terminal is programmable. For example, it could perform a reduction operation.</li>
<li><code>Edge</code>: An output terminal is connected to the input terminal using edges. Multiple edges can connect to an input terminal enabling data to come from multiple sources and an output terminal might connect to multiple successors implying a broadcast operation.</li>
<li><code>TemplateTask</code>: This wraps a user-defined function with informal signature void f(TaskId, Arg0, Arg1, ..., OutputTerminals). A task is marked for execution when all input arguments are received. To instantiate a TemplateTask, make_tt function is used. <br  />
</li>
</ul>
<h1>How to write a simple TTG program?</h1>
<ul>
<li>Step 1 : Include the required header files. For MADNESS runtime, add the below header file.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;madness/ttg.h&quot;</span></div>
</div><!-- fragment --><p>For PaRSEC runtime, add the below header file. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;parsec/ttg.h&quot;</span></div>
</div><!-- fragment --><p> Import the namespaces required for using the TTG API.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>madness;</div>
<div class="line"><span class="keyword">using namespace </span>madness::ttg;</div>
<div class="line"><span class="keyword">using namespace </span>::<a class="code" href="namespacettg.html">ttg</a>;</div>
<div class="ttc" id="anamespacettg_html"><div class="ttname"><a href="namespacettg.html">ttg</a></div><div class="ttdoc">top-level TTG namespace contains runtime-neutral functionality</div><div class="ttdef"><b>Definition:</b> <a href="keymap_8h_source.html#l00008">keymap.h:8</a></div></div>
</div><!-- fragment --><ul>
<li>Step 2 : Define a TaskId (Key) which represents a unique identifier for each task and which is hashable.</li>
<li>Step 3 : Define a factory that returns a TemplateTask for every function that runs the computation. Below factory function returns a TemplateTask for recursively exploring the wavefronts of the Smith Waterman algorithm. The code adopts several common design motifs of a TTG program. Complete implementation of the algorithm can be found in the <a href="examples/">examples</a> directory.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> funcT, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> make_sw1(<span class="keyword">const</span> funcT&amp; func, <span class="keywordtype">int</span> block_size, <span class="keyword">const</span> std::string &amp;a, <span class="keyword">const</span> std::string &amp;b,</div>
<div class="line">            <span class="keywordtype">int</span> problem_size, Edge&lt;Key, BlockMatrix&lt;T&gt;&gt;&amp; leftedge, Edge&lt;Key, BlockMatrix&lt;T&gt;&gt;&amp; topedge,</div>
<div class="line">            Edge&lt;Key, BlockMatrix&lt;T&gt;&gt;&amp; diagedge, Edge&lt;Key, T&gt;&amp; resultedge) {</div>
<div class="line">  <span class="keyword">auto</span> f = [block_size, problem_size, a, b, func](<span class="keyword">const</span> Key&amp; key, BlockMatrix&lt;T&gt;&amp;&amp; toporleft,</div>
<div class="line">              std::tuple&lt;Out&lt;Key, BlockMatrix&lt;T&gt;&gt;, Out&lt;Key, BlockMatrix&lt;T&gt;&gt;,</div>
<div class="line">              Out&lt;Key, BlockMatrix&lt;T&gt;&gt;, Out&lt;Key, BlockMatrix&lt;T&gt;&gt;, Out&lt;Key, T&gt;&gt;&amp; out) {</div>
<div class="line">    <span class="comment">// Getting the block coordinates</span></div>
<div class="line">    <span class="keyword">auto</span>[i, j] = key;</div>
<div class="line">    <span class="keywordtype">int</span> next_i = i + 1;</div>
<div class="line">    <span class="keywordtype">int</span> next_j = j + 1;</div>
<div class="line">    <span class="keywordtype">int</span> num_blocks = problem_size / block_size;</div>
<div class="line"> </div>
<div class="line">    BlockMatrix&lt;T&gt; X(block_size, block_size);</div>
<div class="line">    <span class="keywordflow">if</span> (i == 0 &amp;&amp; j == 0) {</div>
<div class="line">      <span class="comment">//No top, left or diagonal blocks</span></div>
<div class="line">      X = sw_iterative(i, j, X, X, X, X, block_size, a, b, problem_size);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == 0) {</div>
<div class="line">      <span class="comment">//Only left block, single dependency</span></div>
<div class="line">      X = sw_iterative(i, j, X, toporleft, X, X, block_size, a, b, problem_size);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j == 0) {</div>
<div class="line">      <span class="comment">//Only top block, single dependency</span></div>
<div class="line">      X = sw_iterative(i, j, X, X, toporleft, X, block_size, a, b, problem_size);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//std::cout &lt;&lt; X &lt;&lt; std::endl;</span></div>
<div class="line">    <span class="keywordflow">if</span> (next_i &lt; num_blocks) {</div>
<div class="line">      <span class="comment">//std::cout &lt;&lt; &quot;left &quot; &lt;&lt; next_i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; std::endl;</span></div>
<div class="line">      <span class="keywordflow">if</span> (j == 0)  <span class="comment">// send top block for next block computation</span></div>
<div class="line">        send&lt;0&gt;(Key(next_i, j), X, out);</div>
<div class="line">      <span class="keywordflow">else</span>  <span class="comment">// send top block for next block computation</span></div>
<div class="line">        send&lt;2&gt;(Key(next_i, j), X, out);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (next_j &lt; num_blocks) {</div>
<div class="line">      <span class="keywordflow">if</span> (i == 0)  <span class="comment">// send left block for next block computation</span></div>
<div class="line">        send&lt;0&gt;(Key(i, next_j), X, out);</div>
<div class="line">      <span class="keywordflow">else</span>  <span class="comment">// // send left block for next block computation</span></div>
<div class="line">        send&lt;1&gt;(Key(i, next_j), X, out);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (next_i &lt; num_blocks &amp;&amp; next_j &lt; num_blocks) {</div>
<div class="line">      send&lt;3&gt;(Key(next_i, next_j), X, out); <span class="comment">//send diagonal block for next block computation</span></div>
<div class="line">    }</div>
<div class="line">  </div>
<div class="line">    <span class="keywordflow">if</span> (i == num_blocks - 1 &amp;&amp; j == num_blocks - 1)</div>
<div class="line">      send&lt;4&gt;(Key(i,j), X(block_size-1, block_size-1), out);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  Edge&lt;Key, BlockMatrix&lt;T&gt;&gt; recur(<span class="stringliteral">&quot;recur&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> wrap(f, edges(recur), edges(recur, leftedge, topedge, diagedge, resultedge), <span class="stringliteral">&quot;sw1&quot;</span>, {<span class="stringliteral">&quot;recur&quot;</span>},</div>
<div class="line">              {<span class="stringliteral">&quot;recur&quot;</span>, <span class="stringliteral">&quot;leftedge&quot;</span>, <span class="stringliteral">&quot;topedge&quot;</span>, <span class="stringliteral">&quot;diagedge&quot;</span>, <span class="stringliteral">&quot;resultedge&quot;</span>});</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Step 4 : Define the edges and verify that the graph is connected in the main program.</li>
</ul>
<div class="fragment"><div class="line">ttg_initialize(argc, argv, -1);</div>
<div class="line"> </div>
<div class="line">Edge&lt;Key, BlockMatrix&lt;int&gt;&gt; leftedge, topedge, diagedge;</div>
<div class="line">Edge&lt;Key, int&gt; resultedge;</div>
<div class="line"><span class="keyword">auto</span> s = make_sw1(sw_iterative&lt;int&gt;, block_size, a, b, problem_size, leftedge, topedge,</div>
<div class="line">                diagedge, resultedge);</div>
<div class="line"><span class="keyword">auto</span> s1 = make_sw2(sw_iterative&lt;int&gt;, block_size, a, b, problem_size, leftedge, topedge,</div>
<div class="line">                diagedge, resultedge);</div>
<div class="line"><span class="keyword">auto</span> r = make_result(verify, val1, resultedge);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> connected = <a class="code" href="namespacettg.html#ac7188c696fc09d6f8455b608390cfd20">make_graph_executable</a>(s.get());</div>
<div class="line">assert(connected);</div>
<div class="line">TTGUNUSED(connected);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Graph is connected.\n&quot;</span>;</div>
<div class="ttc" id="anamespacettg_html_ac7188c696fc09d6f8455b608390cfd20"><div class="ttname"><a href="namespacettg.html#ac7188c696fc09d6f8455b608390cfd20">ttg::make_graph_executable</a></div><div class="ttdeci">std::enable_if_t&lt;(std::is_convertible_v&lt; std::remove_const_t&lt; std::remove_reference_t&lt; OpBasePtrs &gt;&gt;, OpBase * &gt; &amp;&amp;...), bool &gt; make_graph_executable(OpBasePtrs &amp;&amp;... ops)</div><div class="ttdef"><b>Definition:</b> <a href="func_8h_source.html#l00053">func.h:53</a></div></div>
</div><!-- fragment --><ul>
<li>Step 5 : Execute the graph.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (ttg_default_execution_context().rank() == 0)</div>
<div class="line">  s-&gt;in&lt;0&gt;()-&gt;send(Key(0,0), BlockMatrix&lt;int&gt;());</div>
<div class="line"> </div>
<div class="line">ttg_execute(ttg_default_execution_context());</div>
<div class="line">ttg_fence(ttg_default_execution_context());</div>
</div><!-- fragment --><ul>
<li>TTG API documentation is available for the following versions:<ul>
<li><a href="https://tesseorg.github.io/ttg/dox-master">master branch</a> .</li>
</ul>
</li>
</ul>
<h1>Task Graph Visualization</h1>
<p>The task graph can be dumped into a DOT format using the below code in the main program after connecting the graph. <a href="https://www.graphviz.org/">GraphViz</a> tools can be used to visualize the task graph.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;==== begin dot ====\n&quot;</span>;</div>
<div class="line">std::cout &lt;&lt; Dot()(s.get()) &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;==== end dot ====\n&quot;</span>;</div>
</div><!-- fragment --><p>Below is a TTG graph generated by Smith Waterman algorithm. Each operation/TemplateTask factory is denoted by a rectangle with input terminals on the top and output terminals listed on the bottom part of the rectangle.</p>
<p><img src="sw-df.png" alt="" class="inline"/></p>
<h1>Acknowledgment</h1>
<p>The development of TTG was made possible by:</p><ul>
<li><a href="https://tesseorg.github.io/">The EPEXA project</a>, currently supported by the National Science Foundation under grants <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931387">1931387</a> at Stony Brook University, <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931347">1931347</a> at Virginia Tech, and <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1931384">1931384</a> at the University of Tennesse, Knoxville.</li>
<li>The TESSE project, supported by the National Science Foundation under grants <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450344">1450344</a> at Stony Brook University, <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450262">1450262</a> at Virginia Tech, and <a href="https://www.nsf.gov/awardsearch/showAward?AWD_ID=1450300">1450300</a> at the University of Tennesse, Knoxville. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->

<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
    Generated at Wed Sep 8 2021 19:37:05 for <a href="https://https://github.com/ValeevGroup/tiledarray/">ttg</a>
    0.1.0 by &#160;<a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
<script type="text/javascript" src="doxy-boot.js"></script>
</html>
